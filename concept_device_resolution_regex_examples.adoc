---
sidebar: sidebar 
permalink: concept_device_resolution_regex_examples.html 
keywords: Automatic, AR, AHR, Host, automatic device resolution, FC, Identify, regex, expressions 
summary:  
---
= 정규식 예


[role="lead"]
정규식을 소스 명명 전략으로 선택한 경우 정규식 예제를 Cloud Insights 자동 확인 메서드에서 사용하는 자체 식에 대한 가이드로 사용할 수 있습니다.



=== 정규식 서식 지정

Cloud Insights 자동 확인을 위한 정규식을 만들 때 _format_ 필드에 값을 입력하여 출력 형식을 구성할 수 있습니다.

기본 설정은 \1입니다. 즉, 정규식과 일치하는 영역 이름이 정규식에서 만든 첫 번째 변수의 내용으로 대체됩니다. 정규식에서 변수 값은 괄호를 사용하여 만들어집니다. 괄호를 여러 개 사용하면 변수가 왼쪽에서 오른쪽으로 숫자로 참조됩니다. 변수는 출력 형식으로 어떤 순서로든 사용할 수 있습니다. 형식 필드에 상수 텍스트를 추가하여 출력에 상수 텍스트를 삽입할 수도 있습니다.

예를 들어 이 영역 명명 규칙에 다음과 같은 영역 이름이 있을 수 있습니다.

 [Zone number]_[data center]_[hostname]_[device type]_[interface number]
* S123_Miami_hostname1_filer_FC1
* S14_Tampa_hostname2_switch_FC4
* S3991_Boston_hostname3_windows2K_FC0
* S44_Raleigh_hostname4_Solaris_FC1


출력을 다음 형식으로 지정할 수 있습니다.

 [hostname]-[data center]-[device type]
이렇게 하려면 변수에 호스트 이름, 데이터 센터 및 장치 유형 필드를 캡처하여 출력에 사용해야 합니다. 다음과 같은 정규식을 사용하면 됩니다.

 .*?_([a-zA-Z0-9]+)_([a-zA-Z0-9]+)_([a-zA-Z0-9]+)_.*
괄호 세 세트가 있으므로 변수 \1, \2 및 \3이 채워집니다.

그런 다음 다음 다음 다음 형식을 사용하여 원하는 형식으로 출력을 받을 수 있습니다.

 \2-\1-\3
출력은 다음과 같습니다.

....
hostname1-Miami-filer
hostname2-Tampa-switch
hostname3-Boston-windows2K
hostname4-Raleigh-solaris
....
변수 사이의 하이픈은 서식이 지정된 출력에 삽입된 상수 텍스트의 예를 제공합니다.



=== 영역 이름을 보여 주는 예제 1

이 예제에서는 정규식을 사용하여 영역 이름에서 호스트 이름을 추출합니다. 다음 영역 이름과 유사한 항목이 있는 경우 정규식을 만들 수 있습니다.

* S0032_myComputer1Name - HBA0
* S0434_myComputer1Name - HBA1
* S0432_myComputer1Name - HBA3


호스트 이름을 캡처하는 데 사용할 수 있는 정규식은 다음과 같습니다.

 S[0-9]+_([a-zA-Z0-9]*)[_-]HBA[0-9]
결과는 S로 시작하는 모든 영역과 일치하며 그 뒤에 숫자 조합, 밑줄, 영숫자 호스트 이름(myComputer1Name), 밑줄 또는 하이픈, 대문자 HBA 및 단일 숫자(0-9)가 옵니다. 호스트 이름만 *\1 * 변수에 저장됩니다.

정규식은 다음과 같이 해당 구성 요소로 나눌 수 있습니다.

* "S"는 영역 이름을 나타내고 식을 시작합니다. 이것은 영역 이름의 시작 부분에 있는 "S"만 일치합니다.
* 괄호 안의 문자 [0-9]는 "S" 뒤에 오는 문자가 0에서 9 사이의 숫자여야 함을 나타냅니다.
* 기호(+)는 이전 대괄호 안의 정보가 한 번 이상 존재해야 함을 나타냅니다.
* 밑줄(_)은 S 다음에 오는 숫자는 영역 이름에 밑줄만 사용해야 함을 의미합니다. 이 예제에서 영역 명명 규칙은 밑줄을 사용하여 호스트 이름과 영역 이름을 구분합니다.
* 필요한 밑줄 뒤에 괄호는 안에 포함된 패턴이 \1 변수에 저장됨을 나타냅니다.
* 괄호 문자 [A-zA-Z0-9]는 일치하는 문자가 대/소문자를 불문하고 모든 문자와 숫자임을 나타냅니다.
* 괄호 뒤에 있는 * (별표)는 괄호 안의 문자가 0번 이상 발생했음을 나타냅니다.
* 괄호 문자 [_-](밑줄 및 대시)는 영숫자 패턴 뒤에 밑줄이나 대시를 사용해야 함을 나타냅니다.
* 정규식의 문자 HBA는 영역 이름에 이 정확한 문자 시퀀스가 발생해야 함을 나타냅니다.
* 괄호 안의 마지막 문자 세트 [0-9]는 0에서 9 사이의 한 자리 숫자와 일치합니다.




=== 예 2

이 예에서는 첫 번째 밑줄 "_"까지 건너뛰고, 그 다음 E와 모든 것을 두 번째 "_"까지 일치시킨 다음 그 이후의 모든 내용을 건너뜁니다.

* 영역: * Z_E2FHDBS01_E1NETAPP

* 호스트 이름: * E2FHDBS01

* RegExp: *. *?_(E. *?) _. *?



=== 예 3

정규식(아래)의 마지막 섹션 주위의 괄호 "( )"는 호스트 이름인 부분을 식별합니다. VSAN3을 호스트 이름으로 사용하려는 경우 [A-zA-Z0-9]+_([A-zA-Z0-9]+). * 입니다

* 존: * A_VSAN3_SR48KENT_A_CX2578_SPA0

* 호스트 이름: * SR48KENT

* RegExp: * [a-zA-Z0-9]+_[a-zA-Z0-9]+_([a-zA-Z0-9]+). *



=== 예제 4에서는 보다 복잡한 명명 패턴을 보여 줍니다

다음 영역 이름과 유사한 항목이 있는 경우 정규식을 만들 수 있습니다.

* myComputerName123-HBA1_Symm1_FA3
* myComputerName123-HBA2_Symm1_FA5
* myComputerName123-HBA3_Symm1_FA7


이러한 항목을 캡처하는 데 사용할 수 있는 정규식은 다음과 같습니다.

 ([a-zA-Z0-9]*)_.*
이 식으로 계산한 후 \1 변수는 _myComputerName123_만 포함합니다.

정규식은 다음과 같이 해당 구성 요소로 나눌 수 있습니다.

* 괄호는 안에 포함된 패턴이 \1 변수에 저장됨을 나타냅니다.
* 괄호 문자 [A-zA-Z0-9]는 모든 문자(대/소문자 구분 없음) 또는 숫자가 일치함을 의미합니다.
* 괄호 뒤에 있는 * (별표)는 괄호 안의 문자가 0번 이상 발생했음을 나타냅니다.
* 정규식의 _ (밑줄) 문자는 영역 이름에 앞의 대괄호와 일치하는 영숫자 문자열 바로 뒤에 밑줄이 있어야 함을 의미합니다.
* 를 클릭합니다. (마침표)는 임의의 문자(와일드카드)와 일치합니다.
* 별표(*)는 이전 기간 와일드카드가 0번 이상 발생할 수 있음을 나타냅니다.
+
즉, 조합을 나타냅니다. * 모든 문자를 임의의 횟수만큼 나타냅니다.





=== 예제 5 패턴 없이 영역 이름을 표시합니다

다음 영역 이름과 유사한 항목이 있는 경우 정규식을 만들 수 있습니다.

* myComputerName_HBA1_Symm1_FA1
* myComputerName123_HBA1_Symm1_FA1


이러한 항목을 캡처하는 데 사용할 수 있는 정규식은 다음과 같습니다.

 (.*?)_.*
1 변수는 첫 번째 영역 이름 예제에서 _myComputerName_ 또는 _myComputerName123_(두 번째 영역 이름 예제의 경우)를 포함합니다. 따라서 이 정규식은 첫 번째 밑줄 이전의 모든 것과 일치합니다.

정규식은 다음과 같이 해당 구성 요소로 나눌 수 있습니다.

* 괄호는 안에 포함된 패턴이 \1 변수에 저장됨을 나타냅니다.
* 마침표 별표(. * )는 임의의 문자(횟수)와 일치합니다.
* 괄호 뒤에 있는 * (별표)는 괄호 안의 문자가 0번 이상 발생했음을 나타냅니다.
* ? Character는 greedy가 아닌 문자와 일치하는 항목을 만듭니다. 이렇게 하면 마지막 밑줄이 아니라 첫 번째 밑줄에서의 일치가 중지됩니다.
* 문자 _. * 는 발견된 첫 번째 밑줄과 그 뒤에 나오는 모든 문자와 일치합니다.




=== 예제 6 컴퓨터 이름을 패턴으로 표시합니다

다음 영역 이름과 유사한 항목이 있는 경우 정규식을 만들 수 있습니다.

* storage1_Switch1_myComputerName123A_A1_FC1
* storage2_Switch2_myComputerName123B_A2_FC2 를 참조하십시오
* storage3_Switch3_myComputerName123T_A3_FC3


이러한 항목을 캡처하는 데 사용할 수 있는 정규식은 다음과 같습니다.

 .*?_.*?_([a-zA-Z0-9]*[ABT])_.*
영역 명명 규칙에 더 많은 패턴이 있으므로 위의 식을 사용하여 A, A B 또는 A T로 끝나는 호스트 이름(예: myComputerName)의 모든 인스턴스(예: \1 변수에 해당 호스트 이름을 지정)와 일치시킬 수 있습니다.

정규식은 다음과 같이 해당 구성 요소로 나눌 수 있습니다.

* 마침표 별표(. * )는 임의의 문자(횟수)와 일치합니다.
* ? Character는 greedy가 아닌 문자와 일치하는 항목을 만듭니다. 이렇게 하면 마지막 밑줄이 아니라 첫 번째 밑줄에서의 일치가 중지됩니다.
* 밑줄 문자는 영역 이름의 첫 번째 밑줄과 일치합니다.
* 따라서 첫 번째. *?_ 조합은 첫 번째 영역 이름 예제에서 storage1_ 문자와 일치합니다.
* 두 번째. *?_ 조합은 첫 번째 과 같이 동작하지만 첫 번째 영역 이름 예제에서 Switch1_과 일치합니다.
* 괄호는 안에 포함된 패턴이 \1 변수에 저장됨을 나타냅니다.
* 괄호 문자 [A-zA-Z0-9]는 모든 문자(대/소문자 구분 없음) 또는 숫자가 일치함을 의미합니다.
* 괄호 뒤에 있는 * (별표)는 괄호 안의 문자가 0번 이상 발생했음을 나타냅니다.
* 정규식 [ABT]의 괄호 문자는 영역 이름의 단일 문자와 일치해야 하며 A, B 또는 T여야 합니다
* 괄호 뒤에 있는 _ (밑줄)은 [ABT] 문자 일치 뒤에 밑줄을 추가해야 함을 나타냅니다.
* 마침표 별표(. * )는 임의의 문자(횟수)와 일치합니다.


따라서 이 결과로 \1 변수에 다음과 같은 영숫자 문자열이 포함됩니다.

* 앞에 몇 개의 영숫자 문자와 두 개의 밑줄이 있습니다
* 뒤에 밑줄과 영숫자 문자를 차례로 사용했습니다.
* 세 번째 밑줄 앞에 A, B 또는 T의 마지막 문자가 있습니다.




=== 예 7

* Zone: * myComputerName123_HBA1_Symm1_FA1

* 호스트 이름: * myComputerName123

* RegExp: * ([a-zA-Z0-9] +) _. *



=== 예 8

이 예제에서는 First _ 앞에 있는 모든 항목을 찾습니다.

영역: MyComputerName_HBA1_Symm1_FA1

MyComputerName123_HBA1_Symm1_FA1

호스트 이름: MyComputerName

RegExp:(. *?) _. *

예제 9 이 예제에서는 1 _ 다음에 있는 모든 항목을 찾은 다음 두 번째 _ 까지 찾습니다.

* 영역: * Z_MyComputerName_StorageName

* 호스트 이름: * MyComputerName

* RegExp: *. *?_(. *?) _. *?



=== 예 10

이 예제에서는 영역 예제에서 "MyComputerName123"을 추출합니다.

* 존: * storage1_Switch1_MyComputerName123A_A1_FC1

storage2_Switch2_MyComputerName123B_A2_FC2 를 참조하십시오

storage3_Switch3_MyComputerName123T_A3_FC3

* 호스트 이름: * MyComputerName123

* RegExp: *. *?. *?_([a-zA-Z0-9]+) * [ABT]_. *



=== 예 11

* 존: * storage1_Switch1_MyComputerName123A_A1_FC1

* 호스트 이름: * MyComputerName123A

* RegExp: *. *?. *?_([a-zA-Z0-9]+) _. *? _



=== 예 12

^(circumflex 또는 caret) * 대괄호 안에 * * 는 식을 부정합니다. 예를 들어 [^FF]는 대문자 또는 소문자 F를 제외한 모든 것을 의미하고 [^a-z]는 소문자 a ~ z를 제외한 모든 것을 의미합니다. 위의 경우 _ 을 제외한 모든 내용을 의미합니다. format 문은 출력 호스트 이름에 "-"를 추가합니다.

* 존: * MHS_apps44_d_a_10a0_0429

* 호스트 이름: * MHS-apps44-d

* RegExp: * ([^_]+) _ ([AB]). * Cloud Insights의 형식:\1-\2 ([^_]+) _ ([^_]+)_([^_]+). * Cloud Insights의 형식:\1-\2-\3



=== 예 13

이 예제에서 저장소 별칭은 "\"로 구분되며 표현식은 "\\"를 사용하여 문자열에 실제로 "\"가 사용되고 있으며 해당 별칭이 표현식 자체의 일부가 아닌 것을 정의해야 합니다.

* 스토리지 별칭: *\Hosts\EDOC01C1\EDOC01N1

* 호스트 이름: * E2801N1

* RegExp: * \\. *?\. *?\\(. *?)



=== 예 14

이 예에서는 영역 예에서 "PD-RV-W-AD-2"를 추출합니다.

* 존: * PD_D-PD-RV-W-AD-2_01

* 호스트 이름: * PD-RV-W-AD-2

* RegExp: * [^-]+-(. *-\d+). *



=== 예 15

이 경우 형식 설정은 호스트 이름에 "US-BV-"를 추가합니다.

* 영역: * SRV_USBVM11_F1

* 호스트 이름: * US-BV-M11

* RegExp: * SRV_USBV([A-Za-Z0-9]+)_F[12]

* 형식: * US-BV-\1
